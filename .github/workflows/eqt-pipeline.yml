name: EQT Pipeline Automation (V2)
on:
  issues:
    types: [opened, labeled, unlabeled, closed, reopened, assigned, edited]
  pull_request:
    types: [opened, synchronize, closed, review_requested]
  workflow_dispatch:

permissions:
  issues: write
  pull-requests: write
  projects: write
  contents: read

jobs:
  automate-status:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: ğŸŒ± æ–° Issue è‡ªåŠ¨æ·»åŠ åˆ°é¡¹ç›®å¹¶è®¾ä¸ºæ–°èŠ½
        if: github.event_name == 'issues' && github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          script: |
            const { graphql } = await import('@actions/github/lib/utils');
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

            // æ·»åŠ é¡¹ç›®é¡¹
            const addMutation = `
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                  item { id }
                }
              }
            `;
            const addResult = await octokit.graphql(addMutation, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              contentId: context.payload.issue.node_id
            });
            const itemId = addResult.addProjectV2ItemById.item.id;

            // æ›´æ–° Status ä¸º ğŸŒ± æ–°èŠ½
            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {singleSelectOptionId: $optionId}
                }) {
                  projectV2Item { id }
                }
              }
            `;
            await octokit.graphql(updateMutation, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              itemId: itemId,
              fieldId: "${{ secrets.STATUS_FIELD_ID }}",
              optionId: "${{ secrets.SEED_OPTION_ID }}"
            });

            // æ·»åŠ æ ‡ç­¾å’Œæ›´æ–° Issue body
            await octokit.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['ğŸŒ±-seed']
            });
            const template = `## ğŸ¯ EQTç ”ç©¶æµç¨‹\n\n**å½“å‰é˜¶æ®µ**: ğŸŒ± æ–°èŠ½\n**ä¼˜å…ˆçº§**: [è¯·é€‰æ‹©]\n**é¢†åŸŸ**: [è¯·é€‰æ‹©]\n**AIéœ€æ±‚**: \n**é¢„æµ‹**: \n**ä¸“å®¶**: \n\n---\n*ç”± EQT Pipeline è‡ªåŠ¨åˆ›å»º*`;
            const originalBody = context.payload.issue.body || '';
            await octokit.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: template + '\n\n' + originalBody
            });

      - name: ğŸ” æ ‡ç­¾ç§»åŠ¨åˆ°è®ºè¯ä¸­
        if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'unlabeled' || github.event.action == 'edited') && contains(github.event.issue.labels.*.name, 'ğŸ”')
        uses: actions/github-script@v7
        with:
          script: |
            const { graphql } = await import('@actions/github/lib/utils');
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

            const itemQuery = `
              query($projectId: ID!, $contentId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(filterBy: {contentIds: [$contentId]}) {
                      nodes { id }
                    }
                  }
                }
              }
            `;
            const itemResult = await octokit.graphql(itemQuery, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              contentId: context.payload.issue.node_id
            });
            const itemId = itemResult.node.items.nodes[0]?.id;
            if (!itemId) {
              console.log('æœªæ‰¾åˆ°é¡¹ç›®é¡¹ï¼Œè·³è¿‡');
              return;
            }

            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {singleSelectOptionId: $optionId}
                }) {
                  projectV2Item { id }
                }
              }
            `;
            await octokit.graphql(updateMutation, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              itemId: itemId,
              fieldId: "${{ secrets.STATUS_FIELD_ID }}",
              optionId: "${{ secrets.EXPLORING_OPTION_ID }}"
            });

            await octokit.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['ğŸ”-exploring']
            });

      - name: ğŸ§ª éªŒè¯ä¸­ - æ›´æ–° Status
        if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'unlabeled' || github.event.action == 'edited') && (contains(github.event.issue.body, 'EQT-Data') || contains(github.event.issue.labels.*.name, 'ğŸ§ª'))
        uses: actions/github-script@v7
        with:
          script: |
            const { graphql } = await import('@actions/github/lib/utils');
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

            const itemQuery = `
              query($projectId: ID!, $contentId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(filterBy: {contentIds: [$contentId]}) {
                      nodes { id }
                    }
                  }
                }
              }
            `;
            const itemResult = await octokit.graphql(itemQuery, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              contentId: context.payload.issue.node_id
            });
            const itemId = itemResult.node.items.nodes[0]?.id;
            if (!itemId) {
              console.log('æœªæ‰¾åˆ°é¡¹ç›®é¡¹ï¼Œè·³è¿‡');
              return;
            }

            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {singleSelectOptionId: $optionId}
                }) {
                  projectV2Item { id }
                }
              }
            `;
            await octokit.graphql(updateMutation, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              itemId: itemId,
              fieldId: "${{ secrets.STATUS_FIELD_ID }}",
              optionId: "${{ secrets.VALIDATING_OPTION_ID }}"
            });

            await octokit.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['ğŸ§ª-validating']
            });

      - name: ğŸ¤ ç¤¾åŒºè¯„å®¡ - æ›´æ–° Status
        if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'unlabeled' || github.event.action == 'edited') && contains(github.event.issue.labels.*.name, 'ğŸ¤')
        uses: actions/github-script@v7
        with:
          script: |
            const { graphql } = await import('@actions/github/lib/utils');
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

            const itemQuery = `
              query($projectId: ID!, $contentId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(filterBy: {contentIds: [$contentId]}) {
                      nodes { id }
                    }
                  }
                }
              }
            `;
            const itemResult = await octokit.graphql(itemQuery, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              contentId: context.payload.issue.node_id
            });
            const itemId = itemResult.node.items.nodes[0]?.id;
            if (!itemId) {
              console.log('æœªæ‰¾åˆ°é¡¹ç›®é¡¹ï¼Œè·³è¿‡');
              return;
            }

            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {singleSelectOptionId: $optionId}
                }) {
                  projectV2Item { id }
                }
              }
            `;
            await octokit.graphql(updateMutation, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              itemId: itemId,
              fieldId: "${{ secrets.STATUS_FIELD_ID }}",
              optionId: "${{ secrets.REVIEWING_OPTION_ID }}"
            });

            await octokit.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['ğŸ¤-reviewing']
            });

      - name: âœ… åˆæ­¥å…±è¯† - æ›´æ–° Status
        if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'unlabeled' || github.event.action == 'edited') && contains(github.event.issue.labels.*.name, 'âœ…')
        uses: actions/github-script@v7
        with:
          script: |
            const { graphql } = await import('@actions/github/lib/utils');
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

            const itemQuery = `
              query($projectId: ID!, $contentId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(filterBy: {contentIds: [$contentId]}) {
                      nodes { id }
                    }
                  }
                }
              }
            `;
            const itemResult = await octokit.graphql(itemQuery, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              contentId: context.payload.issue.node_id
            });
            const itemId = itemResult.node.items.nodes[0]?.id;
            if (!itemId) {
              console.log('æœªæ‰¾åˆ°é¡¹ç›®é¡¹ï¼Œè·³è¿‡');
              return;
            }

            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {singleSelectOptionId: $optionId}
                }) {
                  projectV2Item { id }
                }
              }
            `;
            await octokit.graphql(updateMutation, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              itemId: itemId,
              fieldId: "${{ secrets.STATUS_FIELD_ID }}",
              optionId: "${{ secrets.CONSENSUS_OPTION_ID }}"
            });

            await octokit.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['âœ…-consensus']
            });

      - name: ğŸ¯ PR åˆå¹¶åè®¾ä¸ºæ ¸å¿ƒæ•´åˆ
        if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
        uses: actions/github-script@v7
        with:
          script: |
            const { graphql } = await import('@actions/github/lib/utils');
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

            // æå–å…³è” Issue
            const issueMatch = context.payload.pull_request.title.match(/#(\d+)/) || context.payload.pull_request.body?.match(/closes #(\d+)/i);
            if (!issueMatch) {
              console.log('æœªæ‰¾åˆ°å…³è” Issueï¼Œè·³è¿‡');
              return;
            }
            const issueNumber = parseInt(issueMatch[1]);

            // è·å– Issue node_id
            const { data: issue } = await octokit.rest.issues.get({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            const contentId = issue.node_id;

            // è·å–é¡¹ç›®é¡¹ ID
            const itemQuery = `
              query($projectId: ID!, $contentId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(filterBy: {contentIds: [$contentId]}) {
                      nodes { id }
                    }
                  }
                }
              }
            `;
            const itemResult = await octokit.graphql(itemQuery, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              contentId: contentId
            });
            const itemId = itemResult.node.items.nodes[0]?.id;
            if (!itemId) {
              console.log('æœªæ‰¾åˆ°é¡¹ç›®é¡¹ï¼Œè·³è¿‡');
              return;
            }

            // æ›´æ–° Status ä¸º ğŸ¯ æ ¸å¿ƒæ•´åˆ
            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {singleSelectOptionId: $optionId}
                }) {
                  projectV2Item { id }
                }
              }
            `;
            await octokit.graphql(updateMutation, {
              projectId: "${{ secrets.EQT_PROJECT_NODE_ID }}",
              itemId: itemId,
              fieldId: "${{ secrets.STATUS_FIELD_ID }}",
              optionId: "${{ secrets.INTEGRATION_OPTION_ID }}"
            });

            // å…³é—­ Issue å¹¶æ·»åŠ æ ‡ç­¾
            await octokit.rest.issues.update({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['ğŸ¯-integrated']
            });

  ai-bot-integration:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'edited') && contains(github.event.issue.body, '@EQT-AI-Bot')
    steps:
      - uses: actions/checkout@v4
      - name: æ£€æµ‹ AI éœ€æ±‚å¹¶é€šçŸ¥ Bot
        uses: actions/github-script@v7
        env:
          AI_BOT_WEBHOOK: ${{ secrets.AI_BOT_WEBHOOK }}
        with:
          script: |
            const aiDemand = context.payload.issue.body.match(/@EQT-AI-Bot\s*(.+)/)?.[1];
            if (aiDemand) {
              const response = await fetch(process.env.AI_BOT_WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  issue: context.issue,
                  command: aiDemand,
                  action: 'analyze'
                })
              });
              console.log('AI Bot å“åº”:', response.status);
            } else {
              console.log('æœªæ£€æµ‹åˆ° AI éœ€æ±‚');
            }
