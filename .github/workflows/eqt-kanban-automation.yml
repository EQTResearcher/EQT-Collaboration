name: EQT Kanban Advanced Automation (100% Triggerable Version)

# å…³é”®ä¿®å¤ï¼šæ–°å¢æ‰‹åŠ¨è§¦å‘+å…¨é‡äº‹ä»¶è¦†ç›–ï¼Œç¡®ä¿èƒ½è§¦å‘
on:
  workflow_dispatch: # æ‰‹åŠ¨è§¦å‘æŒ‰é’®ï¼ˆActionsé¡µé¢å¯ç›´æ¥ç‚¹â€œRun workflowâ€ï¼‰
  issues:
    types: [opened, labeled, unlabeled, closed, reopened, edited] # æ–°å¢editedï¼Œæ”¹æ ‡ç­¾/å†…å®¹éƒ½è§¦å‘
  pull_request:
    types: [opened, closed, reopened, ready_for_review, edited, labeled, unlabeled] # è¡¥å……æ ‡ç­¾/ç¼–è¾‘äº‹ä»¶
  project_card:
    types: [created, moved, deleted]

jobs:
  sync-status-full:
    runs-on: ubuntu-latest
    steps:
      - name: Sync labels to status (Full Stage Coverage)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // æ‰‹åŠ¨è§¦å‘æ—¶ï¼Œä»è¾“å…¥å‚æ•°è·å–Issue/PRç¼–å·ï¼ˆæ–°å¢é€»è¾‘ï¼‰
            const manualInput = context.payload.inputs;
            let issue = context.payload.issue;
            let pr = context.payload.pull_request;
            let contentType, contentNumber, isIssueClosed;

            // å¤„ç†æ‰‹åŠ¨è§¦å‘åœºæ™¯
            if (context.eventName === 'workflow_dispatch' && manualInput.contentType && manualInput.contentNumber) {
              contentType = manualInput.contentType;
              contentNumber = parseInt(manualInput.contentNumber);
              isIssueClosed = false; // æ‰‹åŠ¨è§¦å‘é»˜è®¤æŒ‰æ´»è·ƒå¤„ç†
              console.log(`ğŸ“¥ æ‰‹åŠ¨è§¦å‘ï¼šå¤„ç†${contentType} #${contentNumber}`);
            } else {
              // è‡ªåŠ¨è§¦å‘åœºæ™¯ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
              contentType = issue ? 'Issue' : 'PullRequest';
              contentNumber = issue?.number || pr?.number;
              isIssueClosed = issue?.state === 'closed';
              if (!contentNumber) {
                console.log('âŒ æœªæ‰¾åˆ°æœ‰æ•ˆIssueæˆ–PRï¼Œç»ˆæ­¢æµç¨‹');
                return;
              }
              console.log(`ğŸ“¥ è‡ªåŠ¨è§¦å‘ï¼šå¤„ç†${contentType} #${contentNumber}ï¼ˆçŠ¶æ€ï¼š${isIssueClosed ? 'å·²å…³é—­' : 'æ´»è·ƒ'}ï¼‰`);
            }

            try {
              // é¡¹ç›®æŸ¥è¯¢ï¼ˆå·²ä¿®å¤æ ¼å¼ï¼Œæ›¿æ¢1ä¸ºä½ çš„é¡¹ç›®ç¼–å·ï¼‰
              const projectQuery = `
query {
  repository(owner: "${context.repo.owner}", name: "${context.repo.repo}") {
    projectV2(number: 10) { # ã€å¿…æ”¹ã€‘æ›¿æ¢1ä¸ºä½ çš„å®é™…é¡¹ç›®ç¼–å·
      id
      title
      fields(first: 30) {
        nodes {
          ... on ProjectV2SingleSelectFieldConfiguration {
            id
            name
            options { id, name }
          }
          ... on ProjectV2NumberFieldConfiguration {
            id
            name
          }
        }
      }
      items(first: 100) {
        nodes {
          id
          fieldValues(first: 10) {
            nodes {
              ... on ProjectV2ItemFieldSingleSelectValue {
                field { id, name }
                optionId
              }
            }
          }
        }
      }
    }
  }
}
              `;
              
              const { repository } = await github.graphql(projectQuery);
              const projectV2 = repository.projectV2;
              
              if (!projectV2) {
                console.log('âŒ æœªæ‰¾åˆ°é¡¹ç›®ã€ŒEQT Collective Intelligence Pipelineã€');
                return;
              }
              console.log(`âœ… æ‰¾åˆ°é¡¹ç›®ï¼š${projectV2.title}ï¼ˆIDï¼š${projectV2.id}ï¼‰`);

              // æå–æ ¸å¿ƒå­—æ®µ
              const statusField = projectV2.fields.nodes.find(field => 
                field.name.toLowerCase().includes('status') || field.name.includes('çŠ¶æ€')
              );
              const wipLimitField = projectV2.fields.nodes.find(field => 
                field.name.toLowerCase().includes('wip limit') || field.name.includes('wipé™åˆ¶')
              );
              
              if (!statusField) {
                console.log('âŒ æœªæ‰¾åˆ°ã€ŒçŠ¶æ€ã€å­—æ®µï¼Œè¯·åˆ›å»ºå«Status/çŠ¶æ€çš„å•é€‰å­—æ®µ');
                return;
              }
              console.log(`âœ… æ‰¾åˆ°çŠ¶æ€å­—æ®µï¼š${statusField.name}ï¼ˆIDï¼š${statusField.id}ï¼‰`);

              // å…¨é˜¶æ®µçŠ¶æ€æ˜ å°„ï¼ˆä¸è®¾è®¡ä¸€è‡´ï¼‰
              const stageConfig = {
                seed: { 
                  name: 'ğŸŒ± æ–°èŠ½ (Seed)',
                  trigger: () => {
                    // æ‰‹åŠ¨è§¦å‘æ—¶ï¼Œé»˜è®¤å½’ä¸ºæ–°èŠ½
                    if (context.eventName === 'workflow_dispatch') return true;
                    const isNewIssue = context.eventName === 'issues' && context.payload.action === 'opened';
                    const hasNoMatchLabel = !Object.keys(stageConfig).some(key => 
                      key !== 'seed' && (issue?.labels || []).some(l => l.name.toLowerCase().includes(key))
                    );
                    return contentType === 'Issue' && !isIssueClosed && (isNewIssue || hasNoMatchLabel);
                  }
                },
                exploring: { 
                  name: 'ğŸ” è®ºè¯ä¸­ (Exploring)',
                  trigger: () => (issue?.labels || pr?.labels || []).some(l => l.name.toLowerCase().includes('exploring'))
                },
                validating: { 
                  name: 'ğŸ§ª éªŒè¯ä¸­ (Validating)',
                  trigger: () => {
                    const linksEqtData = pr?.body?.includes('EQT-Data') || pr?.head?.repo?.name === 'EQT-Data';
                    const hasValidatingLabel = (issue?.labels || pr?.labels || []).some(l => l.name.toLowerCase().includes('validating'));
                    return linksEqtData || hasValidatingLabel;
                  }
                },
                reviewing: { 
                  name: 'ğŸ¤ ç¤¾åŒºè¯„å®¡ (Reviewing)',
                  trigger: () => (issue?.labels || pr?.labels || []).some(l => l.name.toLowerCase().includes('reviewing'))
                },
                consensus: { 
                  name: 'âœ… åˆæ­¥å…±è¯† (Consensus)',
                  trigger: () => (issue?.labels || pr?.labels || []).some(l => l.name.toLowerCase().includes('consensus'))
                },
                integration: { 
                  name: 'ğŸ¯ æ ¸å¿ƒæ•´åˆ (Integration)',
                  trigger: () => pr?.state === 'closed' && pr?.merged === true
                },
                archived: { 
                  name: 'ğŸ“‹ å·²å½’æ¡£ (Archived)',
                  trigger: () => isIssueClosed
                }
              };

              // åŒ¹é…ç›®æ ‡é˜¶æ®µ
              let targetStage = null;
              Object.values(stageConfig).forEach(stage => {
                if (!targetStage && stage.trigger()) targetStage = stage;
              });
              
              if (!targetStage) {
                console.log('â„¹ï¸ æœªæ‰¾åˆ°åŒ¹é…é˜¶æ®µï¼Œä¿æŒå½“å‰çŠ¶æ€');
                return;
              }
              console.log(`ğŸ”„ åŒ¹é…ç›®æ ‡é˜¶æ®µï¼š${targetStage.name}`);

              // éªŒè¯é˜¶æ®µå­˜åœ¨æ€§
              const targetOption = statusField.options.find(opt => opt.name === targetStage.name);
              if (!targetOption) {
                console.log(`âŒ æ— ã€Œ${targetStage.name}ã€çŠ¶æ€é€‰é¡¹ï¼Œå¯ç”¨é€‰é¡¹ï¼š${statusField.options.map(o => o.name).join(', ')}`);
                return;
              }

              // å¤„ç†æ‰‹åŠ¨è§¦å‘æ—¶çš„å†…å®¹IDï¼ˆæ–°å¢é€»è¾‘ï¼‰
              let contentId;
              if (context.eventName === 'workflow_dispatch') {
                contentId = `${contentType}:${context.repo.owner}/${context.repo.repo}#${contentNumber}`;
              } else {
                contentId = `${contentType}:${context.repo.owner}/${context.repo.repo}#${contentNumber}`;
              }

              // é¡¹ç›®é¡¹æŸ¥è¯¢
              const itemQuery = `
query($projectId: ID!, $contentId: ID!) {
  node(id: $projectId) {
    ... on ProjectV2 {
      items(first: 1, contentId: $contentId) {
        nodes { id }
      }
    }
  }
}
              `;
              
              const { node } = await github.graphql(itemQuery, {
                projectId: projectV2.id,
                contentId: contentId
              });
              
              const projectItem = node.items.nodes[0];
              if (!projectItem) {
                console.log(`â„¹ï¸ æœªæ‰¾åˆ°${contentType}#${contentNumber}çš„é¡¹ç›®é¡¹ï¼Œéœ€æ‰‹åŠ¨æ·»åŠ åˆ°çœ‹æ¿`);
                return;
              }
              console.log(`âœ… æ‰¾åˆ°é¡¹ç›®é¡¹ï¼š${projectItem.id}`);

              // æ‰§è¡ŒçŠ¶æ€æ›´æ–°
              const updateMutation = `
mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $valueId: ID!) {
  updateProjectV2SingleSelectField(
    projectId: $projectId
    itemId: $itemId
    fieldId: $fieldId
    valueId: $valueId
  ) {
    projectV2Item { id }
  }
}
              `;
              
              await github.graphql(updateMutation, {
                projectId: projectV2.id,
                itemId: projectItem.id,
                fieldId: statusField.id,
                valueId: targetOption.id
              });

              // ç»“æœè¾“å‡º
              console.log(`ğŸ‰ çŠ¶æ€æ›´æ–°å®Œæˆï¼- é¡¹ç›®é¡¹ï¼š${projectItem.id} - é˜¶æ®µï¼š${targetStage.name}`);

            } catch (error) {
              console.error('âŒ æµç¨‹å¤±è´¥ï¼š', error.message);
              if (error.errors) console.error('ğŸ“ GraphQLé”™è¯¯ï¼š', JSON.stringify(error.errors, null, 2));
              throw error;
            }

 
