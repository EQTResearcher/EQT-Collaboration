name: EQT Kanban Advanced Automation (Ultimate Fixed Version)

on:
  issues:
    types: [opened, labeled, unlabeled, closed, reopened]
  pull_request:
    types: [opened, closed, reopened, ready_for_review, edited]
  project_card:
    types: [created, moved, deleted]

jobs:
  # å”¯ä¸€çš„çŠ¶æ€åŒæ­¥ä»»åŠ¡ï¼šè¦†ç›–å…¨é˜¶æ®µ+WIPæ ¡éªŒ
  sync-status-full:
    runs-on: ubuntu-latest
    steps:
      - name: Sync labels to status (Full Stage Coverage)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // ========================= 1. åŸºç¡€æ•°æ®åˆå§‹åŒ– =========================
            const { issue, pull_request: pr } = context.payload;
            const contentType = issue ? 'Issue' : 'PullRequest';
            const contentNumber = issue?.number || pr?.number;
            const isIssueClosed = issue?.state === 'closed'; 
            
            if (!contentNumber) {
              console.log('âŒ æœªæ‰¾åˆ°æœ‰æ•ˆIssueæˆ–PRï¼Œç»ˆæ­¢æµç¨‹');
              return;
            }
            console.log(`ğŸ“¥ å¼€å§‹å¤„ç†ï¼š${contentType} #${contentNumber}ï¼ˆçŠ¶æ€ï¼š${isIssueClosed ? 'å·²å…³é—­' : 'æ´»è·ƒ'}ï¼‰`);

            try {
              // ========================= 2. é¡¹ç›®ä¸å­—æ®µæŸ¥è¯¢ï¼ˆç§»é™¤GraphQLå†…éƒ¨æ³¨é‡Šï¼‰ =========================
              // æ³¨æ„ï¼šä¸‹æ–¹GraphQLå­—ç¬¦ä¸²å†…æ— ä»»ä½•æ³¨é‡Šï¼Œé¿å…è§£æé”™è¯¯
              const projectQuery = `
                query {
                  repository(owner: "${context.repo.owner}", name: "${context.repo.repo}") {
                    projectV2(number: 10) { 
                      id
                      title
                      fields(first: 30) {
                        nodes {
                          ... on ProjectV2SingleSelectFieldConfiguration {
                            id
                            name
                            options { id, name }
                          }
                          ... on ProjectV2NumberFieldConfiguration {
                            id
                            name
                          }
                        }
                      }
                      items(first: 100) {
                        nodes {
                          id
                          fieldValues(first: 10) {
                            nodes {
                              ... on ProjectV2ItemFieldSingleSelectValue {
                                field { id, name }
                                optionId
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const { repository } = await github.graphql(projectQuery);
              const projectV2 = repository.projectV2;
              
              if (!projectV2) {
                console.log('âŒ æœªæ‰¾åˆ°é¡¹ç›®ã€ŒEQT Collective Intelligence Pipelineã€');
                return;
              }
              console.log(`âœ… æ‰¾åˆ°é¡¹ç›®ï¼š${projectV2.title}ï¼ˆIDï¼š${projectV2.id}ï¼‰`);

              // æå–æ ¸å¿ƒå­—æ®µï¼ˆçŠ¶æ€å­—æ®µ+WIPé™åˆ¶å­—æ®µï¼‰
              const statusField = projectV2.fields.nodes.find(field => 
                field.name.toLowerCase().includes('status') || field.name.includes('çŠ¶æ€')
              );
              const wipLimitField = projectV2.fields.nodes.find(field => 
                field.name.toLowerCase().includes('wip limit') || field.name.includes('wipé™åˆ¶')
              );
              
              if (!statusField) {
                console.log('âŒ æœªæ‰¾åˆ°ã€ŒçŠ¶æ€ã€å­—æ®µï¼Œè¯·åœ¨é¡¹ç›®ä¸­åˆ›å»ºå•é€‰å­—æ®µï¼ˆåç§°å«Status/çŠ¶æ€ï¼‰');
                return;
              }
              console.log(`âœ… æ‰¾åˆ°çŠ¶æ€å­—æ®µï¼š${statusField.name}ï¼ˆIDï¼š${statusField.id}ï¼‰`);

              // ========================= 3. å…¨é˜¶æ®µçŠ¶æ€æ˜ å°„ï¼ˆåŒ¹é…è®¾è®¡æ–‡ä»¶ï¼‰ =========================
              const stageConfig = {
                seed: { // ğŸŒ± æ–°èŠ½
                  name: 'ğŸŒ± æ–°èŠ½ (Seed)',
                  trigger: () => {
                    const isNewIssue = context.eventName === 'issues' && context.payload.action === 'opened';
                    const hasNoMatchLabel = !Object.keys(stageConfig).some(key => 
                      key !== 'seed' && (issue?.labels || []).some(l => l.name.toLowerCase().includes(key))
                    );
                    return contentType === 'Issue' && !isIssueClosed && (isNewIssue || hasNoMatchLabel);
                  }
                },
                exploring: { // ğŸ” è®ºè¯ä¸­
                  name: 'ğŸ” è®ºè¯ä¸­ (Exploring)',
                  trigger: () => (issue?.labels || pr?.labels).some(l => l.name.toLowerCase().includes('exploring'))
                },
                validating: { // ğŸ§ª éªŒè¯ä¸­
                  name: 'ğŸ§ª éªŒè¯ä¸­ (Validating)',
                  trigger: () => {
                    const linksEqtData = pr?.body?.includes('EQT-Data') || pr?.head?.repo?.name === 'EQT-Data';
                    const hasValidatingLabel = (issue?.labels || pr?.labels).some(l => l.name.toLowerCase().includes('validating'));
                    return linksEqtData || hasValidatingLabel;
                  }
                },
                reviewing: { // ğŸ¤ ç¤¾åŒºè¯„å®¡
                  name: 'ğŸ¤ ç¤¾åŒºè¯„å®¡ (Reviewing)',
                  trigger: () => (issue?.labels || pr?.labels).some(l => l.name.toLowerCase().includes('reviewing'))
                },
                consensus: { // âœ… åˆæ­¥å…±è¯†
                  name: 'âœ… åˆæ­¥å…±è¯† (Consensus)',
                  trigger: () => (issue?.labels || pr?.labels).some(l => l.name.toLowerCase().includes('consensus'))
                },
                integration: { // ğŸ¯ æ ¸å¿ƒæ•´åˆ
                  name: 'ğŸ¯ æ ¸å¿ƒæ•´åˆ (Integration)',
                  trigger: () => pr?.state === 'closed' && pr?.merged === true
                },
                archived: { // ğŸ“‹ å·²å½’æ¡£
                  name: 'ğŸ“‹ å·²å½’æ¡£ (Archived)',
                  trigger: () => isIssueClosed
                }
              };

              // ========================= 4. åŒ¹é…ç›®æ ‡é˜¶æ®µ =========================
              let targetStage = null;
              Object.values(stageConfig).forEach(stage => {
                if (!targetStage && stage.trigger()) targetStage = stage;
              });
              
              if (!targetStage) {
                console.log('â„¹ï¸ æœªæ‰¾åˆ°åŒ¹é…çš„é˜¶æ®µï¼Œä¿æŒå½“å‰çŠ¶æ€');
                return;
              }
              console.log(`ğŸ”„ åŒ¹é…ç›®æ ‡é˜¶æ®µï¼š${targetStage.name}`);

              // éªŒè¯é˜¶æ®µåœ¨é¡¹ç›®ä¸­å­˜åœ¨
              const targetOption = statusField.options.find(opt => opt.name === targetStage.name);
              if (!targetOption) {
                console.log(`âŒ é¡¹ç›®ä¸­æ— ã€Œ${targetStage.name}ã€çŠ¶æ€é€‰é¡¹`);
                console.log('å¯ç”¨çŠ¶æ€é€‰é¡¹ï¼š', statusField.options.map(o => o.name).join(', '));
                return;
              }

              // ========================= 5. WIPé™åˆ¶æ ¡éªŒï¼ˆç§»é™¤GraphQLå†…éƒ¨æ³¨é‡Šï¼‰ =========================
              let isWipExceeded = false;
              if (wipLimitField && targetStage.name !== 'ğŸ“‹ å·²å½’æ¡£ (Archived)' && targetStage.name !== 'ğŸ¯ æ ¸å¿ƒæ•´åˆ (Integration)') {
                // GraphQLå­—ç¬¦ä¸²å†…æ— æ³¨é‡Šï¼Œé¿å…è§£æé”™è¯¯
                const wipQuery = `
                  query($projectId: ID!, $fieldId: ID!, $statusFieldId: ID!, $optionId: ID!) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        items(first: 1, filterBy: {fieldValue: {fieldId: $statusFieldId, optionId: $optionId}}) {
                          nodes {
                            fieldValues(first: 1, filterBy: {fieldId: $fieldId}) {
                              nodes {
                                ... on ProjectV2ItemFieldNumberValue {
                                  number
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const wipResult = await github.graphql(wipQuery, {
                  projectId: projectV2.id,
                  fieldId: wipLimitField.id,
                  statusFieldId: statusField.id,
                  optionId: targetOption.id
                });

                const wipLimit = wipResult.node.items.nodes[0]?.fieldValues.nodes[0]?.number || 0;
                if (wipLimit > 0) {
                  // ç»Ÿè®¡å½“å‰é˜¶æ®µå¡ç‰‡æ•°é‡
                  const currentStageItems = projectV2.items.nodes.filter(item => {
                    const statusValue = item.fieldValues.nodes.find(v => 
                      v.field.id === statusField.id && v.optionId === targetOption.id
                    );
                    return !!statusValue;
                  });

                  if (currentStageItems.length + 1 > wipLimit) {
                    isWipExceeded = true;
                    console.log(`âš ï¸ WIPé™åˆ¶è­¦å‘Šï¼š${targetStage.name} æœ€å¤š${wipLimit}ä¸ªå¡ç‰‡ï¼Œå½“å‰å·²${currentStageItems.length}ä¸ª`);
                  }
                }
              }

              // ========================= 6. é¡¹ç›®é¡¹æŸ¥è¯¢ä¸çŠ¶æ€æ›´æ–°ï¼ˆç§»é™¤GraphQLå†…éƒ¨æ³¨é‡Šï¼‰ =========================
              const contentId = `${contentType}:${context.repo.owner}/${context.repo.repo}#${contentNumber}`;
              // GraphQLå­—ç¬¦ä¸²å†…æ— æ³¨é‡Š
              const itemQuery = `
                query($projectId: ID!, $contentId: ID!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 1, contentId: $contentId) {
                        nodes { id }
                      }
                    }
                  }
                }
              `;
              
              const { node } = await github.graphql(itemQuery, {
                projectId: projectV2.id,
                contentId: contentId
              });
              
              const projectItem = node.items.nodes[0];
              if (!projectItem) {
                console.log(`â„¹ï¸ æœªæ‰¾åˆ°${contentType}#${contentNumber}å¯¹åº”çš„é¡¹ç›®é¡¹ï¼Œéœ€æ‰‹åŠ¨æ·»åŠ åˆ°çœ‹æ¿`);
                return;
              }
              console.log(`âœ… æ‰¾åˆ°é¡¹ç›®é¡¹ï¼š${projectItem.id}`);

              // æ‰§è¡ŒçŠ¶æ€æ›´æ–°ï¼ˆGraphQLå­—ç¬¦ä¸²å†…æ— æ³¨é‡Šï¼‰
              const updateMutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $valueId: ID!) {
                  updateProjectV2SingleSelectField(
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    valueId: $valueId
                  ) {
                    projectV2Item { id }
                  }
                }
              `;
              
              await github.graphql(updateMutation, {
                projectId: projectV2.id,
                itemId: projectItem.id,
                fieldId: statusField.id,
                valueId: targetOption.id
              });

              // ========================= 7. ç»“æœè¾“å‡º =========================
              console.log(`ğŸ‰ çŠ¶æ€æ›´æ–°å®Œæˆï¼`);
              console.log(`- é¡¹ç›®é¡¹ï¼š${projectItem.id}`);
              console.log(`- ç›®æ ‡é˜¶æ®µï¼š${targetStage.name}`);
              if (isWipExceeded) console.log(`- æ³¨æ„ï¼šå½“å‰é˜¶æ®µå·²æ¥è¿‘WIPé™åˆ¶ï¼Œè¯·ä¼˜å…ˆå¤„ç†å­˜é‡å¡ç‰‡`);

            } catch (error) {
              console.error('âŒ è‡ªåŠ¨åŒ–æµç¨‹å¤±è´¥ï¼š', error.message);
              if (error.errors) console.error('ğŸ“ GraphQLé”™è¯¯è¯¦æƒ…ï¼š', JSON.stringify(error.errors, null, 2));
              throw error;
            }

 
