name: EQT Kanban Advanced Automation

on:
  issues:
    types: [opened, labeled, unlabeled, closed, reopened]
  pull_request:
    types: [opened, closed, reopened, ready_for_review]
  project_card:
    types: [created, moved, deleted]  # æ³¨æ„ï¼šæ–°é¡¹ç›®ä½¿ç”¨ project_v2 ä¸­çš„äº‹ä»¶ï¼Œä½†è¿™é‡Œæš‚ä¿ç•™ï¼›å¦‚éœ€è°ƒæ•´ï¼Œå¯æ”¹ä¸º project_v2

jobs:
  sync-status:
    runs-on: ubuntu-latest
    steps:
      - name: Sync labels to status
        uses: actions/github-script@v7  # æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬ï¼Œæ”¯æŒ GraphQL
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}  # ç¡®ä¿ token æœ‰ projects:write æƒé™
          script: |
            const { issue } = context.payload;
            if (!issue) return;  // åªå¤„ç† issue äº‹ä»¶

            // GraphQL æŸ¥è¯¢ï¼šè·å–é¡¹ç›®ã€å­—æ®µå’Œé¡¹
            const query = `
              query GetProjectAndItem($owner: String!, $repo: String!, $issueNumber: Int!) {
                repository(owner: $owner, name: $repo) {
                  projectV2(number: 1) {  # å‡è®¾é¡¹ç›®æ˜¯ä»“åº“çš„ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼›å¦åˆ™ç”¨åç§°æŸ¥è¯¢
                    id
                    fields(first: 20) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options {
                            id
                            name
                          }
                        }
                      }
                    }
                    items(first: 20) {
                      nodes {
                        id
                        fieldValues(first: 10) {
                          nodes {
                            ... on ProjectV2ItemFieldSingleSelectValue {
                              optionId
                            }
                          }
                        }
                        content {
                          ... on Issue {
                            number
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const variables = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issueNumber: issue.number
            };

            const { repository } = await github.rest.graphql(query, variables);
            const project = repository.projectV2;
            if (!project) {
              core.warning('æœªæ‰¾åˆ°æ–°é¡¹ç›® (V2)ã€‚è¯·ç¡®è®¤é¡¹ç›®å·²è¿ç§»å¹¶æŒ‡å®šæ­£ç¡®ç¼–å·ã€‚');
              return;
            }

            // æ ‡ç­¾åˆ°çŠ¶æ€é€‰é¡¹çš„æ˜ å°„ï¼ˆå‡è®¾ Status å­—æ®µé€‰é¡¹åç§°åŒ¹é…ï¼‰
            const labelToStatusOption = {
              'exploring': 'ğŸ” è®ºè¯ä¸­ (Exploring)',
              'reviewing': 'ğŸ¤ ç¤¾åŒºè¯„å®¡ (Reviewing)', 
              'consensus': 'âœ… åˆæ­¥å…±è¯† (Consensus)',
              'integration': 'ğŸ¯ æ ¸å¿ƒæ•´åˆ (Integration)'
            };

            // æŸ¥æ‰¾ Status å­—æ®µ
            const statusField = project.fields.nodes.find(f => f.name === 'Status');
            if (!statusField) {
              core.warning('æœªæ‰¾åˆ° Status å­—æ®µã€‚è¯·åœ¨æ–°é¡¹ç›®ä¸­åˆ›å»ºå•é€‰å­—æ®µ "Status" å¹¶æ·»åŠ é€‰é¡¹ã€‚');
              return;
            }

            // æŸ¥æ‰¾å½“å‰ issue çš„é¡¹ç›®é¡¹
            const item = project.items.nodes.find(i => 
              i.content?.number === issue.number
            );
            if (!item) {
              core.warning(`æœªæ‰¾åˆ° issue #${issue.number} çš„é¡¹ç›®é¡¹ã€‚`);
              return;
            }

            // æ£€æŸ¥æ ‡ç­¾å¹¶æ›´æ–°çŠ¶æ€
            let newStatus = null;
            for (const [label, statusName] of Object.entries(labelToStatusOption)) {
              if (issue.labels.some(l => l.name.toLowerCase().includes(label))) {
                newStatus = statusField.options.find(opt => opt.name === statusName);
                if (newStatus) break;
              }
            }

            if (newStatus) {
              // GraphQL å˜æ›´ï¼šæ›´æ–°é¡¹çš„çŠ¶æ€å­—æ®µ
              const mutation = `
                mutation UpdateItemField($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(
                    input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }
                  ) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;

              const mutationVariables = {
                projectId: project.id,
                itemId: item.id,
                fieldId: statusField.id,
                optionId: newStatus.id
              };

              await github.rest.graphql(mutation, mutationVariables);
              core.info(`å·²å°† issue #${issue.number} çš„çŠ¶æ€æ›´æ–°ä¸º "${newStatus.name}"`);
            } else {
              core.info(`issue #${issue.number} æ— åŒ¹é…æ ‡ç­¾ï¼Œæ— éœ€æ›´æ–°ã€‚`);
            }

  ai-bot-trigger:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'ğŸŒ± seed')
    steps:
      - name: Trigger AI Bot analysis
        run: |
          echo "æ–°ç§å­è®®é¢˜ #${{ github.event.issue.number }} éœ€è¦AIåˆ†æ"
          # å®ç°æ‚¨çš„ AI bot API è°ƒç”¨ï¼Œä¾‹å¦‚ï¼š
          # curl -X POST https://your-ai-bot.com/analyze \
          #   -H "Authorization: Bearer ${{ secrets.AI_BOT_TOKEN }}" \
          #   -H "Content-Type: application/json" \
          #   -d '{"issue": ${{ toJson(github.event.issue) }}}'
